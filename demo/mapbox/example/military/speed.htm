<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>DEM & Model</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <script include="jquery" src="../../libs/zondyclient/include-lib-local.js"></script>
    <script include="threebox" src="../../libs/zondyclient/include-mapboxgl-local.js"></script>
    <!--引入当前页面样式表-->
    <link href="../../css/mapboxgl/style.css" rel="stylesheet" type="text/css" />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script>
        //使用严格模式
        "use strict";
        //
        var origin = [4.686205805789757, 36.12743569751477, 5];
        //mapbox服务数据的访问令牌，若使用mapbox提供的样式必须要设置令牌
        mapboxgl.accessToken =
            "pk.eyJ1Ijoid29ya2luZ2RvZyIsImEiOiJjamQyZmszenczMHRoMzRuczVzaGthbGhnIn0.HTkYTE-R82N3azqscSyHkA";
        //实例化Map对象加载地图
        var map = new mapboxgl.Map({
            //地图容器div的id
            container: "map",
            //mapbox提供的样式
            style: "http://192.168.10.185:6163/igs/rest/mrms/vtiles/styles/军测.json", // 使用MapBox官方的样式,
            //地图中心点
            center: origin,
            //地图当前缩放级数
            zoom: 16
        });

        //添加导航控件
        map.addControl(new mapboxgl.NavigationControl());

        //注册地图加载事件
        map.on("load", function () {
            addDem();
            addCar();
        });

        function addDem() {
            map.addSource("dem", {
                type: "raster-dem",
                url: "mapbox://mapbox.terrain-rgb"
            });
            map.addLayer({
                    id: "hillshading",
                    source: "dem",
                    type: "hillshade"
                    // insert below waterway-river-canal-shadow;
                    // where hillshading sits in the Mapbox Outdoors style
                },
                "水域陆地_F_160000_DN10500432_REG"
            );
        }

        var carmodel;
        var timestamp = 0,
            timeline;

        function addCar() {
            map.addLayer({
                id: "custom_model_car",
                type: "custom",
                onAdd: function (map, gl) {
                    CarMode(map, gl);
                },
                render: function (gl, matrix) {
                    threebox.update(Date.now(), "mbx");
                }
            });
        }

        function CarMode(map, gl) {
            window.threebox = new Threebox(map, gl);
            threebox.setupDefaultLights();

            var loader = new THREE.GLTFLoader();

            loader.load('../../data/model/cesium/GroundVehicle/GroundVehicle.glb', (
                function (gltf) {
                    carmodel = gltf;
                    // rotate object so it's sitting on its base
                    carmodel.scene.rotation.x = -Math.PI * 1.5
                    carmodel.scene.scale.set(10, 10, 10);
                    $.get('../../data/military/车辆实时.json', function (line) {
                        timeline = line.features[0].geometry.coordinates;
                        timeline[0].push(5);
                        console.log(timeline[0]);
                        threebox.addAtCoordinate(carmodel.scene, timeline[0]);
                        playAnimate();
                    });

                    //threebox.addAtCoordinate(carmodel.scene, origin);
                }).bind(this));
        }

        var intersect = 0,
            intermax, intersects = [];

        function playAnimate() {
            if (intersect == 0) {
                if (timestamp >= timeline.length - 1) timestamp = 0;
                intersects = calculatePositon(timeline[timestamp], timeline[timestamp + 1], 0.0001);
                intermax = intersects.length;
                intersect++;
                timestamp++;
            } else {
                if (intersect >= intermax - 1) {
                    intersect = 0;
                    intermax = 0;
                } else {
                    intersects[intersect].push(5);
                     var position = intersects[intersect];
                     var rotate = calculateDirection(intersects[intersect], intersects[intersect + 1]);
                     carmodel.scene.rotation.y = -rotate * Math.PI / 180;
                     threebox.moveToCoordinate(carmodel.scene, position);
                     map.setCenter({
                         lng: position[0],
                         lat: position[1]
                     });
                    intersect++;
                }
            }

            requestAnimationFrame(playAnimate);
        }

        function calculatePositon(dot1, dot2, len) {
            var points = [];

            var x, y;
            var EPS = len;
            var scale = 1;
            dot1[0] *= scale;
            dot1[1] *= scale;
            len *= scale;
            var k = (dot1[0] - dot2[0]) / (dot1[1] - dot2[1]);
            var y1, y2, y3;

            var dis = Math.sqrt(
                (dot1[0] - dot2[0]) * (dot1[0] - dot2[0]) +
                (dot1[1] - dot2[1]) * (dot1[1] - dot2[1])
            ); 

            points.push(dot1);
            for (var i = len; i < dis; i += len) {
                y1 = dot1[1] - Math.sqrt((i * i) / (k * k + 1));
                y2 = dot1[1] + Math.sqrt((i * i) / (k * k + 1));
                y3 = dot1[1];
                y = dot1[1] > dot2[1] ? y1 : y2;
                x = dot1[0] - k * (y3 - y);
                points.push([x / scale, y / scale]);
            }
            points.push(dot2);

            return points;
        }

        function calculateDirection(p1, p2) {
            var dx, dy, da;
            var m_dDirection = 0;

            dx = p2[0] - p1[0];
            dy = p2[1] - p1[1];

            if (dx == 0) {
                if (dy > 0) m_dDirection = 0;
                else m_dDirection = 180;
            } else {
                if (dx > 0) {
                    if (dy == 0) {
                        m_dDirection = 90;
                    } else {
                        if (dy > 0) {
                            da = Math.abs(dx / dy);
                            m_dDirection = (Math.atan(da) * 180) / Math.PI;
                        } else {
                            if (dy < 0) {
                                da = Math.abs(dx / dy);
                                m_dDirection = (Math.atan(da) * 180) / Math.PI;
                                m_dDirection = 180 - m_dDirection;
                            }
                        }
                    }
                } else {
                    if (dy == 0) {
                        m_dDirection = 270;
                    } else {
                        if (dy >= 0) {
                            da = Math.abs(dx / dy);
                            m_dDirection = (Math.atan(da) * 180) / Math.PI;
                            m_dDirection = 360 - m_dDirection;
                        } else {
                            da = Math.abs(dx / dy);
                            m_dDirection = (Math.atan(da) * 180) / Math.PI;
                            m_dDirection = 180 + m_dDirection;
                        }
                    }
                }
            }
            return m_dDirection;
        }
    </script>
</body>

</html>